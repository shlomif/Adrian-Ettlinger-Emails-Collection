Status: R
X-Status: NT
X-Keywords: 
Return-Path: <aettlinger@worldnet.att.net>
Delivered-To: shlomif@vipe.technion.ac.il
Received: (qmail 15703 invoked from network); 5 Jul 2002 13:40:35 -0000
Received: from mtiwmhc22.worldnet.att.net (204.127.131.47)
  by vipe.technion.ac.il with SMTP; 5 Jul 2002 13:40:35 -0000
Received: from computer ([12.78.221.77]) by mtiwmhc22.worldnet.att.net
          (InterMail vM.4.01.03.27 201-229-121-127-20010626) with SMTP
          id <20020705134002.RSCU19902.mtiwmhc22.worldnet.att.net@computer>
          for <shlomif@vipe.technion.ac.il>; Fri, 5 Jul 2002 13:40:02 +0000
Message-ID: <000701c22428$fb007c40$4ddd4e0c@computer>
From: "Adrian Ettlinger" <aettlinger@worldnet.att.net>
To: "Shlomi Fish" <shlomif@vipe.technion.ac.il>
References: <Pine.LNX.4.33L2.0207051445270.13209-100000@vipe.technion.ac.il>
Subject: Re: FcPro - FCS -- new problem
Date: Fri, 5 Jul 2002 09:35:40 -0400
MIME-Version: 1.0
Content-Type: multipart/mixed;
  boundary="----=_NextPart_000_0004_01C22407.55AF0660"
X-Priority: 3
X-MSMail-Priority: Normal
X-Mailer: Microsoft Outlook Express 5.00.2615.200
X-MimeOLE: Produced By Microsoft MimeOLE V5.00.2615.200
X-KMail-EncryptionState: 
X-KMail-SignatureState: 
X-KMail-MDN-Sent: 

This is a multi-part message in MIME format.

------=_NextPart_000_0004_01C22407.55AF0660
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: 7bit

Hi Shlomi,

    I'm attaching the two relevant source files, but I doubt very much that
they are going to be useful for your diagnosis.

    There's another clue that I'd been dismissing, but now that I think
about it, it's probably significant.  After the crash, I always find that
the number of freecells has been reset from four to one.  This is a strong
indication that the problem is an out-of-bounds memory write.   Such an
occurrence can have quite varying effects depending not only on the type of
operating system, but also on what applications are running, or how memory
happens to be allocated for the existing application.  And very often the
effect can be totally benign.

    I haven't yet run it under Windows 98, and will probably send another
message very shortly as to the result.

Best regards, ----------------------------Adrian


------=_NextPart_000_0004_01C22407.55AF0660
Content-Type: application/octet-stream;
	name="Free2.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename="Free2.c"

// copyight 2001 Adrian Ettlinger

 /* Program for testing winnability of positions in Free Cell.
 */
=0A=

/************************************************************************=
*****
Brief summary of the game:
=0A=

Deal four columns of six cards each, and four of seven cards each, =
spreading
each column so the cards are all visible.  These columns form the =
"tableau".
There is a "holding area" that can hold a maximum of four cards.  The =
only
cards that can be moved are the bottommost card in each column and the =
cards
in the holding area.  As Aces become available (i.e., can be moved) they =
are
moved to start four "foundation" piles, which are then built up in suit =
to
Kings.  The object is to move all the cards to the foundations.
=0A=

A move consists of moving one card.  A card can move onto a tableau =
column
if the card being moved is the opposite color and one rank lower than =
the
card it is being played onto (i.e., the tableau builds down, alternating
color).  Any card can be moved to an empty holding area spot, or to an =
empty
column in the tableau.
=0A=

Input format is 52 cards represented either as rank then suit or suit =
then
rank, where suit is one of CDHS and rank is one of A23456789TJQK.  =
Lower-case
is okay too.  Other characters such as spaces and line breaks are =
ignored and
can be used for readability.  E.g.:
=0A=

7h 9s Kc 5d 8h 3h 6d 9d
7d As 3c Js 8c Kd 2d Ac
2s Qc Jh 8d Th Ts 9h 5h
Qs 6c 4s 6h Ad 8s 2h 4d
Ah 7s 3d Jd 9c 3s Qd Kh
7c 4c Jc Qh 2c Tc 5s 4h
5c Td Ks 6s
=0A=

*************************************************************************=
****/
=0A=
#define FCS 1

#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include "main.h"
#include "FCSolve.h"
#include "custom.h"
#include "settings.h"
#include "freecell.h"
#include "cmd_line_chop.h"

extern HANDLE ghSolverThread2 ;
//extern int Free2Solver(Position*, int, int, int, int, char* =
FCSolveMoves);
#ifdef FCS
//extern int Free2Solver(Position*, int, int, int, int, void*) ;
extern int Free2Solver(Position*, int, int, int, char**, void*) ;
extern LPSTR moves_string ;
#endif
//extern int Free2Solver(Position*, int, int, int, int) ;
//(orig, NoFcs, limit, mode, option, ret_moves)
void FCSolveReadOriginal (void);
extern int gnFCSolveIndex, SolrSel ;
extern char PresortC[] ;
extern BOOL gbSolver, gbAbortA, gbAbortM ;
BOOL gbAbortG ;
int result, FCSmode, FCSlimit ;
static char szTemp[50] ;
FILE *gfpSolFile;
#include "time.h"
#define GET_TIME(var) {time(&var);}
time_t	 stime, etime, oetime, getime ;
int ItCount, ItCounts ;=0A=
extern BOOL gbSearchF2 ;
extern BOOL PlayMode2 ;=20
char szFCSPFname[] =3D "fcspres.txt" ;
HFILE hpfile ;
//LPSTR FCSPresBuf ;
int pflen ;
args_man_t * args_man ;

char pres[][66] =3D {"--method soft-dfs -to 0123456789 -step 500 -nst ",
"--method soft-dfs -to 0123467 -step 500 -nst ",
"--method random-dfs -seed 2 -to 0[01][23456789] -step 500 -nst ",
"--method random-dfs -seed 1 -to 0[0123456789] -step 500 -nst ",
"--method random-dfs -seed 3 -to 0[01][23467] -step 500 -nst ",
"--method random-dfs -seed 4 -to 0[0123467] -step 500 -nst ",
"--method random-dfs -to [01][23456789] -seed 8 -step 500 -nst ",
"--method random-dfs -to [01][23456789] -seed 268 -step 500 ",
"--method random-dfs -seed 1 -to 0[0123456789] -step 500 -nst ",=20
"--method random-dfs -seed 2 -to 0[01][23456789] -step 500 -nst ",
"--method random-dfs -seed 3 -to 0[01][23467] -step 500 -nst ",
"--method a-star -step 500 -nst ",
"--method a-star -to 0123467 -step 500 -nst ",
"--method random-dfs -seed 4 -to 0[0123467] -step 500 -nst ",
"--method soft-dfs -step 500" } ;
char FCSPresBuf[600] ;

int signal_step(int ItCount)
{
	sprintf (szTemp, "At %d Iterations...", ItCount);
	StatusOut(szTemp) ;
	if ((gnMaxTime !=3D 0) && (((gnSolve =3D=3D SOLVE_RANGE) || (gnSolve =
=3D=3D SOLVE_LIST))))=20
	{
	time (&getime) ;
    if ((getime - stime) >=3D gnMaxTime)
		{
		ItCounts =3D ItCount ;
		gbAbortG =3D TRUE ;
		return 1 ;
		}
	}
	if ((!gbAbortA) && (!gbAbortM))=20
		return 0 ;
return 1 ;
}

DWORD Free2Main (HWND hwnd)
{
	// set below normal priority so we can use menu

//extern int SupMove ;
//extern int FcMode ;
/*
sprintf(szTemp, "sm- %d fc- %d ", SupMove, FcMode) ;
MessageBox(GetFocus(), szTemp, "FCP", MB_OK) ;
*/
//FcMode =3D 0 ;   // TEMP TEST
//SupMove =3D 1 ;
DWORDLONG nGame;
int WinCount, AboCount, ImpCount, i ;
=09
	SetThreadPriority (GetCurrentThread (),=20
						THREAD_PRIORITY_BELOW_NORMAL);

//	result =3D Free2Solver (&orig, NUM_FCS, 2000000, 0, 0, =
(LPSTR)FCSolveMoves);
	if (gnMaxHands =3D=3D 0)
		FCSlimit =3D 2000000 ;
	else
		FCSlimit =3D gnMaxHands ;
	FCSmode =3D 0 ;
//	if (isdigit(PresortC[0]))
//		FCSmode =3D PresortC[0] & 3 ;
//	if ((PresortC[1] =3D=3D 'o') || (PresortC[1] =3D=3D 'O'))
//		FCSmode =3D FCSmode | 0x10000 ;
//sprintf(szTemp, "mh- %d fcsl- %d PC1- %c fcsm -%d", gnMaxHands, =
FCSlimit, PresortC[0], FCSmode) ;
//MessageBox(GetFocus(), szTemp, "FC", MB_OK) ;

//NEW CODE FOR PRESET SYSTEM 5/25/02 & 7/3/02
FCSPresBuf[0] =3D 0 ;
/*
if (PresortC[0] =3D=3D 'X')
	hpfile =3D _lopen(szFCSPFname, OF_READ) ;
if (hpfile !=3D -1)
	{
	pflen =3D _llseek(hpfile, 0L, 2) ;=09
	_llseek(hpfile, 0L, 0) ;
//	FCSPresBuf =3D malloc(pflen + 1) ;=09
	_lread(hpfile, (LPSTR)FCSPresBuf, pflen) ;
	FCSPresBuf[pflen] =3D 0 ;
	_lclose(hpfile) ;
	}
else  =20
	{
*/
  if ((PresortC[0] =3D=3D '1') || (PresortC[0] =3D=3D '2') || =
((PresortC[0] >=3D 'A') && (PresortC[0] <=3D 'O')))
		{
		if (PresortC[0] =3D=3D '1')
			{
			for (i =3D 0 ; i < 8 ; i++)
				lstrcat(FCSPresBuf, pres[i]) ;
			}
		if (PresortC[0] =3D=3D '2')
			{
			for (i =3D 8 ; i < 15 ; i++)
				lstrcat(FCSPresBuf, pres[i]) ;
			}
		if (isalpha(PresortC[0]))
			lstrcat(FCSPresBuf, pres[PresortC[0] - 'A']) ;
		}
	else
		{
		hpfile =3D -1 ;
		hpfile =3D _lopen(szFCSPFname, OF_READ) ;
		if (hpfile !=3D -1)
		{
		pflen =3D _llseek(hpfile, 0L, 2) ;=09
		_llseek(hpfile, 0L, 0) ;
		_lread(hpfile, (LPSTR)FCSPresBuf, pflen) ;
		FCSPresBuf[pflen] =3D 0 ;
		_lclose(hpfile) ;
		}
	else
		FCSPresBuf[0] =3D 0 ;
	}
//	args_man_t * args_man =3D args_man_alloc()  ;
if (FCSPresBuf[0] !=3D 0)
{
	args_man =3D args_man_alloc()  ;
	args_man_chop(args_man, FCSPresBuf);
}
//sprintf(szTemp, "ac- %d st0- %s st1- %s", args_man->argc, =
args_man->argv[0], args_man->argv[1]) ;
//MessageBox(GetFocus(), szTemp, "FC", MB_OK) ;
=09
	if ((gnSolve !=3D SOLVE_RANGE) && (gnSolve !=3D SOLVE_LIST))
   {=20
	time (&stime);
	FCSolveReadOriginal ();
	gfpSolFile =3D fopen ("solution.txt", "w");
#ifdef FCS
//	result =3D Free2Solver (&orig, NUM_FCS, FCSlimit, FCSmode, 0, =
&signal_step);
if (FCSPresBuf[0] !=3D 0)
{
//MainMessage("pre-Solv") ;
	result =3D Free2Solver (&orig, NUM_FCS, FCSlimit, args_man->argc, =
args_man->argv, &signal_step);
//MainMessage("post-Solv") ;
	args_man_free(args_man) ;
}
else
	result =3D Free2Solver (&orig, NUM_FCS, FCSlimit, 0, 0, &signal_step);
#endif
	if (result < 0)
	{
		if (gbSearchF2)
		{
			gbSearchF2 =3D FALSE ;
			KillTimer(hwnd, 1) ;
			MessageBox(hwnd, "Impossible.", "Solver2", MB_ICONEXCLAMATION | =
MB_OK) ;
			gbSearchF2  =3D TRUE ;
			SetTimer(hwnd, 1, 20,NULL) ;
		}
		sprintf(szTemp, "Impossible. %d Iterations", -result) ;
	}
	if (result > 0)
	{
		sprintf(szTemp, "Winnable. %d Iterations", result) ;
	}
	if (result =3D=3D 0)
		lstrcpy (szTemp, "Intractable");
	if (gbAbortA)
	{
		strcpy (szTemp, "Aborted");
		gbAbortA =3D gbAbortM =3D FALSE ;
	}
	StatusOut (szTemp);
	if (result > 0)
	{
#ifdef FCS
		lstrcpy(FCSolveMoves,moves_string) ;
#endif
		gnFCSolveIndex =3D lstrlen(FCSolveMoves) ;
		if (((gnGameNumber < 0xf00000000)|| gbCustomGame) &&=20
//					(gnSolve =3D=3D SOLVE_SOLUTION) && !gbAbort)
					(gnSolve =3D=3D SOLVE_SOLUTION))
		{
		if (gnFCSolveIndex > (STD_MOVES_PER_LINE * STD_MAX_LINES * =
AUTO_PER_MOVE - 2))
			MainMessage("Winnable, but....\nSolution is too long\nto be =
replayed.") ;
		else
		{
			gbSolver2 =3D TRUE ;
			PostMessage (hwnd, WM_USER+100, 0, 0);
		}
		}
	}
		time (&etime);
	fprintf (gfpSolFile, "Game #%s  %s", FmtGameNo(gnGameNumber), szTemp);
    if (result =3D=3D 0)
		result =3D gnMaxHands ;
	fprintf (gfpSolFile, "  Elapsed Seconds: %d\n", etime - stime);	=09
	fclose (gfpSolFile);
   }
   else
   {   //  Range or List solve
		gfpSolFile =3D fopen ("solrange.txt", "w");
		WinCount =3D AboCount =3D ImpCount =3D 0 ;
		time (&oetime);
		if (gnSolve =3D=3D SOLVE_LIST)
	{
		gnFirstGame =3D GetSolveGame(0) ;
		if (gnFirstGame < 0)
			return 0 ;
		gnLastGame =3D 0x7ffffffff ; // set to allow to run all the way
	}
  // this is the loop for a range=20
	// (firstgame =3D lastgame =3D 1 if not a range)

	for (nGame =3D gnFirstGame; (nGame <=3D gnLastGame) && !gbAbortA && =
!gbAbortM ; nGame++)
	{
		time (&stime);
		gnGameNumber =3D nGame;
		FreeCellInit (FALSE);
		FCSolveReadOriginal ();
#ifdef FCS
//		result =3D Free2Solver (&orig, NUM_FCS, FCSlimit, FCSmode, 0, =
&signal_step);
if (FCSPresBuf[0] !=3D 0)
		result =3D Free2Solver (&orig, NUM_FCS, FCSlimit, args_man->argc, =
args_man->argv, &signal_step);
else
		result =3D Free2Solver (&orig, NUM_FCS, FCSlimit, 0, 0, &signal_step);
#endif
//		result =3D Free2Solver (&orig, NUM_FCS, FCSlimit, FCSmode, 0);
		time (&etime);
		if (result > 0 )
		{=09
			WinCount++ ;
			lstrcpy(szTemp,"Winnable") ;
		}
		if (result < 0 )
		{
			ImpCount++ ;
			lstrcpy(szTemp,"Impossible") ;
		}
		if (result =3D=3D 0)
		{
			AboCount++ ;
			if (!gbAbortG)
				result =3D gnMaxHands ;
			else
			{
				result =3D ItCounts ;
				gbAbortG =3D FALSE ;
			}
			lstrcpy(szTemp, "Intractable") ;
		}
		if (gbAbortM)
		{
//MessageBox(GetFocus(), "22", "FC", MB_OK) ;
			lstrcpy (szTemp, "Aborted");
		}
		if (!SolrSel || (((NUM_FCS < 2) && (result >=3D 0)) || ((NUM_FCS > 1) =
&& (result <=3D 0))))
		{
			fprintf (gfpSolFile, "%s", FmtGameNo(gnGameNumber)) ;
			fprintf (gfpSolFile, " %s %8d", szTemp, abs(result)) ;
			fprintf (gfpSolFile, " iterations") ;
			time (&etime);
			fprintf (gfpSolFile, " %d seconds\n", etime - stime);
		}
		if ((gnSolve =3D=3D SOLVE_LIST)	&& (nGame =3D=3D gnGameNumber))
		{
			nGame =3D GetSolveGame(1) ;
			if (nGame < 0)
				nGame =3D 0x7ffffffff ; // force end
			nGame-- ; // because loop will increment number
		}
		if (gbAbortM || gbAbortA)
		{
//MessageBox(GetFocus(), "2", "FC", MB_OK) ;
			nGame =3D gnLastGame ;
			gbAbortM =3D gbAbortA =3D FALSE ;
			break ;
		}
	}	  =20
	fprintf (gfpSolFile, "\nNumber of Freecells: %d   Mode: ", NUM_FCS);
	fprintf (gfpSolFile, PresortC);
	fprintf (gfpSolFile, "\n");
	if (gnMaxTime)
		fprintf (gfpSolFile, "Max Time: %d  ", gnMaxTime) ;
	if (gnMaxHands)
		fprintf (gfpSolFile, "Max Iterations: %d  ", gnMaxHands) ;
	fprintf (gfpSolFile, "\n");
	fprintf (gfpSolFile, "Winnables: %d\n", WinCount);
	fprintf (gfpSolFile, "Impossibles: %d\n", ImpCount);
	fprintf (gfpSolFile, "Intractables: %d\n", AboCount);
	if ((etime - oetime) < 3600)
      fprintf (gfpSolFile, "Total time: %d Minutes, %d Seconds\n", =
(etime - oetime)/60,=09
					(etime - oetime)%60) ;
	else
      fprintf (gfpSolFile, "Total time: %d Hours, %d Minutes, %d =
Seconds\n",
			(etime - oetime)/3600, ((etime - oetime)%3600) / 60,=09
					(etime - oetime)%60) ;
	fclose(gfpSolFile) ;
	if (FCSPresBuf[0] !=3D 0)
		args_man_free(args_man) ;
	MainStartGame (TRUE);
   }	  =20
	ghSolverThread2 =3D NULL;
	if (gnSolve =3D=3D SOLVE_SOLUTION)
		PlayMode2 =3D TRUE ;
	else
		PlayMode2 =3D FALSE ;
	gbSolver2 =3D FALSE ;
    ExitThread (0);
	return 0; // not reached
}

------=_NextPart_000_0004_01C22407.55AF0660
Content-Type: application/octet-stream;
	name="fc_pro_iface.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename="fc_pro_iface.c"

#include <stdlib.h>=0A=

#include <stdio.h>=0A=

#include <string.h>=0A=

#include <assert.h>=0A=

=0A=

#if 0=0A=

#include "Fcsolvex.h"=0A=

#else=0A=

#include "main.h"=0A=

#include "Fcsolve.h"=0A=

#endif=0A=

#include "fcs_user.h"=0A=

#include "fcs_cl.h"=0A=

//extern int signal_step(int) ;=0A=

int NumFCs ;=0A=

char * moves_string;=0A=

static const char * ranks_map =3D "0A23456789TJQK";=0A=

=0A=

char szTemp[50] ;=0A=

=0A=

static char * rank_to_string(int rank, char * buf)=0A=

{=0A=

    buf[0] =3D ranks_map[rank];=0A=

    buf[1] =3D '\0';=0A=

    return buf;=0A=

}=0A=

=0A=

static const char * suits_map =3D "CDSH";=0A=

=0A=

static char * suit_to_string(int suit, char * buf)=0A=

{=0A=

    buf[0] =3D suits_map[suit];=0A=

    buf[1] =3D '\0';=0A=

    return buf;=0A=

}=0A=

=0A=

static char * card_to_string(Card card, char * buf)=0A=

{=0A=

    rank_to_string(card&0x0F,buf);=0A=

    suit_to_string(card>>4,buf+1);=0A=

=0A=

    return buf;=0A=

}=0A=

=0A=

static char * position_to_string(Position * pos, int num_freecells)=0A=

{=0A=

    int a, stack;=0A=

    char buffer[4000], temp[4][20];=0A=

    char * s_end;=0A=

=0A=

    buffer[0] =3D '\0';=0A=

    s_end =3D buffer;=0A=

    =0A=

    for(a=3D0;a<4;a++)=0A=

    {=0A=

        if (pos->foundations[a] !=3D 0)=0A=

        {=0A=

            break;=0A=

        }=0A=

    }=0A=

    if (a < 4)=0A=

    {=0A=

        s_end +=3D sprintf(s_end, "Foundations:");=0A=

        for(a=3D0;a<4;a++)=0A=

        {=0A=

            if (pos->foundations[a] !=3D 0)=0A=

            {=0A=

                s_end +=3D sprintf(=0A=

                    s_end, =0A=

                    " %s-%s", =0A=

                    suit_to_string(a, temp[0]),=0A=

                    rank_to_string(pos->foundations[a], temp[1])=0A=

                    );=0A=

            }=0A=

        }=0A=

        *s_end =3D '\n';=0A=

        s_end++;=0A=

    }=0A=

    s_end +=3D sprintf(s_end, "Freecells:");=0A=

    for(a=3D0;a<num_freecells;a++)=0A=

    {=0A=

        if (pos->hold[a] =3D=3D 0)=0A=

        {=0A=

            s_end +=3D sprintf(s_end, " -");=0A=

        }=0A=

        else=0A=

        {=0A=

            s_end +=3D sprintf(s_end, " %s", =
card_to_string(pos->hold[a], temp[0]));=0A=

        }=0A=

    }=0A=

    *s_end =3D '\n';=0A=

    s_end++;=0A=

=0A=

    for(stack=3D0;stack<8;stack++)=0A=

    {=0A=

        for(a=3D0;a<pos->tableau[stack].count;a++)=0A=

        {=0A=

            s_end +=3D =0A=

                sprintf(=0A=

                    s_end, =0A=

                    "%s%s", =0A=

                    ((a =3D=3D 0)? "" : " "),=0A=

                    card_to_string(pos->tableau[stack].cards[a], temp[0])=0A=

                );                                =0A=

        }=0A=

        *s_end =3D '\n';=0A=

        s_end++;=0A=

    }=0A=

    *s_end =3D '\0';=0A=

=0A=

    return strdup(buffer);=0A=

}=0A=

=0A=

=0A=

=0A=

=0A=

enum FCS_IFACE_MODES=0A=

{=0A=

    FCS_IFACE_MODE_DFS,=0A=

    FCS_IFACE_MODE_A_STAR,=0A=

=0A=

    FCS_IFACE_MODE_OPT =3D 0x10000,=0A=

};=0A=

#ifdef FC89=0A=

int Cvtf89(int fcn)=0A=

{=0A=

	if ((NumFCs > 7) && (fcn >=3D 7))=0A=

		return (fcn+3) ;=0A=

	return fcn ;=0A=

}=0A=

#endif=0A=

=0A=

struct fcs_extended_move_struct=0A=

{=0A=

    fcs_move_t move;=0A=

    int to_empty_stack;=0A=

};=0A=

=0A=

typedef struct fcs_extended_move_struct fcs_extended_move_t;=0A=

=0A=

=0A=

static char * render_move(fcs_extended_move_t move, char * string)=0A=

{=0A=

    /* Save the third character which will be set to '\0' by the sprintf.=0A=

     * It's a kludge, but it works.=0A=

     * */=0A=

#if 0=0A=

    char c =3D string[2];=0A=

	char b ;  //ABE=0A=

    int num_chars =3D 2;=0A=

#endif=0A=

    =0A=

    switch(fcs_move_get_type(move.move))=0A=

    {=0A=

        case FCS_MOVE_TYPE_STACK_TO_STACK:=0A=

                if (move.to_empty_stack && =
(fcs_move_get_num_cards_in_seq(move.move) > 1))=0A=

                {=0A=

                    sprintf(string, "%i%iv%x", =0A=

                        1+fcs_move_get_src_stack(move.move),=0A=

                        1+fcs_move_get_dest_stack(move.move),=0A=

                        fcs_move_get_num_cards_in_seq(move.move)=0A=

                        );=0A=

                }=0A=

                else=0A=

                {=0A=

                    sprintf(string, "%i%i", =0A=

                        1+fcs_move_get_src_stack(move.move),=0A=

                        1+fcs_move_get_dest_stack(move.move)=0A=

                        );=0A=

                }=0A=

        break;=0A=

=0A=

        case FCS_MOVE_TYPE_FREECELL_TO_STACK:=0A=

				sprintf(string, "%c%i", =0A=

#ifndef FC89=0A=

                    ('a'+fcs_move_get_src_freecell(move.move)),=0A=

#else=0A=

                    ('a'+Cvtf89(fcs_move_get_src_freecell(move.move))),=0A=

#endif=0A=

                    1+fcs_move_get_dest_stack(move.move)=0A=

                    );=0A=

		break;=0A=

=0A=

        case FCS_MOVE_TYPE_FREECELL_TO_FREECELL:=0A=

                sprintf(string, "%c%c",=0A=

#ifndef FC89=0A=

                    ('a'+fcs_move_get_src_freecell(move.move)),=0A=

                    ('a'+fcs_move_get_dest_freecell(move.move))=0A=

#else=0A=

                    ('a'+Cvtf89(fcs_move_get_src_freecell(move.move))),=0A=

                    ('a'+Cvtf89(fcs_move_get_dest_freecell(move.move)))=0A=

#endif=0A=

					);                        =0A=

        break;=0A=

=0A=

        case FCS_MOVE_TYPE_STACK_TO_FREECELL:=0A=

                sprintf(string, "%i%c",=0A=

                    1+fcs_move_get_src_stack(move.move),=0A=

#ifndef FC89=0A=

                    ('a'+fcs_move_get_dest_freecell(move.move))=0A=

#else=0A=

                    ('a'+Cvtf89(fcs_move_get_dest_freecell(move.move)))=0A=

#endif=0A=

                    );=0A=

//sprintf(szTemp, "StF fc-%d np-%d ", fcs_move_get_dest_freecell(move), =
NumFCs) ;=0A=

//MainMessage(szTemp) ;=0A=

		break;=0A=

=0A=

        case FCS_MOVE_TYPE_STACK_TO_FOUNDATION:=0A=

                sprintf(string, "%ih", =
1+fcs_move_get_src_stack(move.move));=0A=

        break;=0A=

        =0A=

=0A=

        case FCS_MOVE_TYPE_FREECELL_TO_FOUNDATION:=0A=

#ifndef FC89=0A=

				sprintf(string, "%ch", ('a'+fcs_move_get_src_freecell(move.move)));=0A=

#else=0A=

                sprintf(string, "%ch", =
('a'+Cvtf89(fcs_move_get_src_freecell(move.move))));=0A=

#endif=0A=

        break;=0A=

=0A=

        case FCS_MOVE_TYPE_SEQ_TO_FOUNDATION:=0A=

                sprintf(string, "%ih", =
fcs_move_get_src_stack(move.move));=0A=

        break;=0A=

=0A=

        default:=0A=

            string[0] =3D '\0';=0A=

        break;=0A=

    }=0A=

#if 0=0A=

    /* Restore that character */=0A=

    string[2] =3D c;=0A=

	b =3D string[0] ;  // Swap characters -- ABE=0A=

	string[0] =3D string[1] ;=0A=

	string[1] =3D b ;=0A=

#endif=0A=

    return string+strlen(string);=0A=

}=0A=

=0A=

static char * cmd_line_known_parameters[] =3D { NULL };=0A=

=0A=

=0A=

struct moves_processed_struct=0A=

{=0A=

    int next_move_idx;=0A=

    int num_moves;=0A=

    int max_num_moves;=0A=

    fcs_extended_move_t * moves;=0A=

};=0A=

=0A=

typedef struct moves_processed_struct moves_processed_t;=0A=

=0A=

void moves_processed_add_new_move(moves_processed_t * moves, =
fcs_extended_move_t new_move)=0A=

{=0A=

    moves->moves[moves->num_moves++] =3D new_move;=0A=

    if (moves->num_moves =3D=3D moves->max_num_moves)=0A=

    {=0A=

        moves->max_num_moves +=3D 32;=0A=

        moves->moves =3D realloc(moves->moves, sizeof(moves->moves[0]) * =
moves->max_num_moves);=0A=

    }=0A=

}=0A=

=0A=

moves_processed_t * moves_processed_gen(Position * orig, int NoFcs, void =
* instance)=0A=

{=0A=

    Position pos;=0A=

    moves_processed_t * ret;=0A=

    int virtual_stack_len[8];=0A=

    int virtual_freecell_len[12];=0A=

    int i, j, move_idx, num_back_end_moves;=0A=

    fcs_move_t move, out_move;=0A=

=0A=

    pos =3D *orig;=0A=

    =0A=

    ret =3D malloc(sizeof(*ret));=0A=

    ret->num_moves =3D 0;=0A=

    ret->max_num_moves =3D num_back_end_moves =3D =
freecell_solver_user_get_moves_left(instance);=0A=

    ret->moves =3D malloc(sizeof(ret->moves[0]) * ret->max_num_moves);=0A=

    ret->next_move_idx =3D 0;=0A=

=0A=

    for(i=3D0;i<8;i++)=0A=

    {=0A=

        virtual_stack_len[i] =3D orig->tableau[i].count;        =0A=

    }=0A=

    for(i=3D0;i<NoFcs;i++)=0A=

    {=0A=

        virtual_freecell_len[i] =3D (orig->hold[i] !=3D 0) ? 1 : 0;=0A=

    }=0A=

    =0A=

    for(move_idx=3D0; move_idx < num_back_end_moves ; move_idx ++)=0A=

    {=0A=

        /* =0A=

         * Move safe cards to the foundations =0A=

         * */=0A=

        while (1)=0A=

        {=0A=

            for(i=3D0;i<8;i++)=0A=

            {=0A=

                int rank, suit;=0A=

                Card card;=0A=

                =0A=

                if (pos.tableau[i].count > 0)=0A=

                {=0A=

                    card =3D =
pos.tableau[i].cards[pos.tableau[i].count-1];=0A=

                    rank =3D card & 0x0F;=0A=

                    suit =3D card >> 4;=0A=

                    /* Check if we can safely move it */=0A=

                    if ((pos.foundations[suit^0x1] > rank-2) &&=0A=

                        (pos.foundations[suit^0x1^0x2] > rank-2) && =0A=

                        (pos.foundations[suit^0x2] > rank-3) &&=0A=

                        (pos.foundations[suit] =3D=3D rank-1))=0A=

                    {=0A=

                        fcs_extended_move_t new_move;=0A=

                        =0A=

                        pos.foundations[suit]++;=0A=

                        pos.tableau[i].count--;=0A=

                        fcs_move_set_type(new_move.move, =
FCS_MOVE_TYPE_STACK_TO_FOUNDATION);=0A=

                        fcs_move_set_src_stack(new_move.move, i);=0A=

                        /* (suit+1)&0x3 converts it to FCS order */=0A=

                        fcs_move_set_foundation(new_move.move, =
(suit+1)&0x3);=0A=

                        moves_processed_add_new_move(ret, new_move);=0A=

                        =0A=

                        break;=0A=

                    }=0A=

                }=0A=

            }=0A=

            for(j=3D0;j<NoFcs;j++)=0A=

            {=0A=

                int rank, suit;=0A=

                Card card;=0A=

=0A=

                if (pos.hold[j] !=3D 0)=0A=

                {=0A=

                    card =3D pos.hold[j];=0A=

                    rank =3D card & 0x0F;=0A=

                    suit =3D card >> 4;=0A=

                    /* Check if we can safely move it */=0A=

                    if ((pos.foundations[suit^0x1] > rank-2) &&=0A=

                        (pos.foundations[suit^0x1^0x2] > rank-2) && =0A=

                        (pos.foundations[suit^0x2] > rank-3) &&=0A=

                        (pos.foundations[suit] =3D=3D rank-1))=0A=

                    {=0A=

                        fcs_extended_move_t new_move;=0A=

                        pos.foundations[suit]++;=0A=

                        pos.hold[j] =3D 0;=0A=

                        fcs_move_set_type(new_move.move, =
FCS_MOVE_TYPE_FREECELL_TO_FOUNDATION);=0A=

                        fcs_move_set_src_freecell(new_move.move, j);=0A=

                        fcs_move_set_foundation(new_move.move, =
(suit+1)&0x3);=0A=

                        moves_processed_add_new_move(ret, new_move);=0A=

=0A=

                        break;=0A=

                    }                        =0A=

                    =0A=

                }=0A=

            }=0A=

            if ((i =3D=3D 8) && (j =3D=3D NoFcs))=0A=

            {=0A=

                break;=0A=

            }=0A=

        }=0A=

        freecell_solver_user_get_next_move(instance, &move);=0A=

=0A=

        {=0A=

            int src, dest, len;=0A=

            Card card;=0A=

            switch(fcs_move_get_type(move))=0A=

            {=0A=

                case FCS_MOVE_TYPE_STACK_TO_FOUNDATION:=0A=

                    {=0A=

                        src =3D fcs_move_get_src_stack(move);=0A=

                        assert(virtual_stack_len[src] >=3D =
pos.tableau[src].count);=0A=

                        if (virtual_stack_len[src] =3D=3D =
pos.tableau[src].count)=0A=

                        {=0A=

                            len =3D virtual_stack_len[src];=0A=

                            card =3D pos.tableau[src].cards[len-1];=0A=

                            pos.foundations[card >> 4]++;=0A=

                            virtual_stack_len[src]--;=0A=

                            pos.tableau[src].count--;=0A=

                            {=0A=

                                fcs_extended_move_t ext_move;=0A=

                                ext_move.move =3D move;=0A=

                                                            =0A=

                                moves_processed_add_new_move(ret, =
ext_move);=0A=

                            }=0A=

                        }=0A=

                        else=0A=

                        {=0A=

                            virtual_stack_len[src]--;=0A=

                        }=0A=

                    }=0A=

                    break;=0A=

=0A=

                case FCS_MOVE_TYPE_FREECELL_TO_FOUNDATION:=0A=

                    {=0A=

                        src =3D fcs_move_get_src_freecell(move);=0A=

                        assert((virtual_freecell_len[src] =3D=3D 1));=0A=

                        if (pos.hold[src] =3D=3D 0)=0A=

                        {=0A=

                            /* Do nothing */=0A=

                        }=0A=

                        else=0A=

                        {=0A=

                            {=0A=

                                fcs_extended_move_t ext_move;=0A=

                                ext_move.move =3D move;=0A=

                                                            =0A=

                                moves_processed_add_new_move(ret, =
ext_move);=0A=

                            }=0A=

                            pos.hold[src] =3D 0;=0A=

                        }=0A=

                        virtual_freecell_len[src] =3D 0;=0A=

                    }=0A=

                    break;=0A=

=0A=

                case FCS_MOVE_TYPE_FREECELL_TO_STACK:=0A=

                    {=0A=

                        src =3D fcs_move_get_src_freecell(move);=0A=

                        dest =3D fcs_move_get_dest_stack(move);=0A=

                        assert(virtual_freecell_len[src] =3D=3D 1);=0A=

                        if (pos.hold[src] =3D=3D 0)=0A=

                        {=0A=

                            /* Do nothing */=0A=

                        }=0A=

                        else=0A=

                        {=0A=

                            {=0A=

                                fcs_extended_move_t ext_move;=0A=

                                ext_move.move =3D move;=0A=

                                moves_processed_add_new_move(ret, =
ext_move);=0A=

                            }=0A=

                            =
pos.tableau[dest].cards[pos.tableau[dest].count++] =3D pos.hold[src];=0A=

                            pos.hold[src] =3D 0;=0A=

                        }                        =0A=

                        virtual_freecell_len[src] =3D 0;=0A=

                        virtual_stack_len[dest]++;=0A=

                    }=0A=

                    break;=0A=

=0A=

               case FCS_MOVE_TYPE_STACK_TO_FREECELL:=0A=

                    {=0A=

                        src =3D fcs_move_get_src_stack(move);=0A=

                        dest =3D fcs_move_get_dest_freecell(move);=0A=

                        assert(virtual_stack_len[src] > 0);=0A=

                        assert(pos.tableau[src].count <=3D =
virtual_stack_len[src]);=0A=

                        if (pos.tableau[src].count < =
virtual_stack_len[src])=0A=

                        {=0A=

                            /* Do nothing */=0A=

                        }=0A=

                        else=0A=

                        {=0A=

                            {=0A=

                                fcs_extended_move_t ext_move;=0A=

                                ext_move.move =3D move;=0A=

                                moves_processed_add_new_move(ret, =
ext_move);=0A=

                            }=0A=

                            pos.hold[dest] =3D =
pos.tableau[src].cards[--pos.tableau[src].count];=0A=

                        }=0A=

                        virtual_stack_len[src]--;=0A=

                        virtual_freecell_len[dest] =3D 1;=0A=

                    }=0A=

                    break;=0A=

=0A=

               case FCS_MOVE_TYPE_STACK_TO_STACK:=0A=

                    {=0A=

                        int num_cards, virt_num_cards;=0A=

                        =0A=

                        src =3D fcs_move_get_src_stack(move);=0A=

                        dest =3D fcs_move_get_dest_stack(move);=0A=

                        num_cards =3D =
fcs_move_get_num_cards_in_seq(move);=0A=

                        assert(virtual_stack_len[src] >=3D =
pos.tableau[src].count);=0A=

                        if (virtual_stack_len[src] > =
pos.tableau[src].count)=0A=

                        {=0A=

#ifndef min=0A=

#define min(a,b) (((a)<(b))?(a):(b))=0A=

#endif=0A=

                            virt_num_cards =3D =
min((virtual_stack_len[src]-pos.tableau[src].count), num_cards);=0A=

#undef min=0A=

                            virtual_stack_len[src] -=3D virt_num_cards;=0A=

                            virtual_stack_len[dest] +=3D virt_num_cards;=0A=

                            num_cards -=3D virt_num_cards;=0A=

                        }=0A=

                        if (num_cards > 0)=0A=

                        {=0A=

                            fcs_move_set_type(out_move, =
FCS_MOVE_TYPE_STACK_TO_STACK);=0A=

                            fcs_move_set_src_stack(out_move, src);=0A=

                            fcs_move_set_dest_stack(out_move, dest);=0A=

                            fcs_move_set_num_cards_in_seq(out_move, =
num_cards);=0A=

                            {=0A=

                                fcs_extended_move_t ext_move;=0A=

                                ext_move.move =3D out_move;=0A=

                                ext_move.to_empty_stack =3D =
(pos.tableau[dest].count =3D=3D 0);=0A=

                                moves_processed_add_new_move(ret, =
ext_move);=0A=

                            }=0A=

                            for(i=3D0;i<num_cards;i++)=0A=

                            {=0A=

                                =
pos.tableau[dest].cards[pos.tableau[dest].count+i] =3D =
pos.tableau[src].cards[pos.tableau[src].count-num_cards+i];=0A=

                            }=0A=

                            pos.tableau[dest].count +=3D num_cards;=0A=

                            pos.tableau[src].count -=3D num_cards;=0A=

                            virtual_stack_len[dest] +=3D num_cards;=0A=

                            virtual_stack_len[src] -=3D num_cards;=0A=

                        }=0A=

                    }=0A=

                    break;=0A=

                =0A=

            }=0A=

        }=0A=

    }=0A=

=0A=

#if 0=0A=

    /* =0A=

     * This is a debugging code. It seems that everything works well =0A=

     * */=0A=

    {=0A=

        int count=3D0;=0A=

        for(i=3D0;i<8;i++)=0A=

        {=0A=

            count +=3D (pos.tableau[i].count =3D=3D 0);=0A=

            count +=3D (virtual_stack_len[i] =3D=3D 0);=0A=

        }=0A=

        for(i=3D0;i<NoFcs;i++)=0A=

        {=0A=

            count +=3D (pos.hold[i] =3D=3D 0);=0A=

            count +=3D (virtual_freecell_len[i] =3D=3D 0);=0A=

        }=0A=

        printf("count=3D%i\n", count);=0A=

    }=0A=

#endif=0A=

=0A=

    return ret;=0A=

    =0A=

}=0A=

=0A=

int moves_processed_get_moves_left(moves_processed_t * moves)=0A=

{=0A=

    return moves->num_moves- moves->next_move_idx;=0A=

}=0A=

=0A=

int moves_processed_get_next_move(moves_processed_t * moves, =
fcs_extended_move_t * move)=0A=

{=0A=

    if (moves->next_move_idx =3D=3D moves->num_moves)=0A=

    {=0A=

        return 1;=0A=

    }=0A=

    *move =3D moves->moves[moves->next_move_idx++];=0A=

    return 0;=0A=

}=0A=

=0A=

void moves_processed_free(moves_processed_t * moves)=0A=

{=0A=

    free(moves->moves);=0A=

    free(moves);=0A=

}=0A=

=0A=

=0A=

//int Free2Solver(Position * orig, int NoFcs, int limit, int mode, int =
option, char * * ret_moves)=0A=

int Free2Solver(Position * orig, int NoFcs, int limit, int =
cmd_line_argc, char * * cmd_line_argv,=0A=

	 int (*signal_step)(int step_limit))=0A=

{=0A=

    char * state_string;=0A=

    void * instance;=0A=

    int verdict;=0A=

    int num_iters;=0A=

    int ret;=0A=

    int current_limit =3D 1000;=0A=

    char * err_str;=0A=

    int ret_arg, parser_ret;=0A=

=0A=

=0A=

    state_string =3D position_to_string(orig, NoFcs);=0A=

    =0A=

    instance =3D freecell_solver_user_alloc();=0A=

=0A=

	NumFCs =3D NoFcs ;=0A=

=0A=

    parser_ret =3D freecell_solver_user_cmd_line_parse_args(=0A=

            instance,=0A=

            cmd_line_argc,=0A=

            cmd_line_argv,=0A=

            0,=0A=

            cmd_line_known_parameters,=0A=

            NULL,=0A=

            NULL,=0A=

            &err_str,=0A=

            &ret_arg=0A=

            );=0A=

=0A=

    if (parser_ret =3D=3D FCS_CMD_LINE_UNRECOGNIZED_OPTION)=0A=

    {=0A=

        freecell_solver_user_free(instance);        =0A=

        return 0;=0A=

    }=0A=

    =0A=

            =0A=

    freecell_solver_user_set_game(=0A=

        instance,=0A=

=0A=

        NoFcs,=0A=

        8,=0A=

        1,=0A=

        FCS_SEQ_BUILT_BY_ALTERNATE_COLOR,=0A=

        0,=0A=

        FCS_ES_FILLED_BY_ANY_CARD=0A=

        );=0A=

=0A=

    freecell_solver_user_limit_iterations(instance, current_limit);=0A=

=0A=

#if 0=0A=

    freecell_solver_user_set_solving_method(=0A=

        instance,=0A=

        (((mode & 0xFFFF) =3D=3D FCS_IFACE_MODE_DFS) ?=0A=

            FCS_METHOD_SOFT_DFS :=0A=

            FCS_METHOD_A_STAR=0A=

        )=0A=

    );=0A=

=0A=

    freecell_solver_user_set_solution_optimization(=0A=

        instance,=0A=

        (mode & FCS_IFACE_MODE_OPT) ? 1 : 0=0A=

        );=0A=

#endif=0A=

          =0A=
//MainMessage("SB") ;
    verdict =3D freecell_solver_user_solve_board(instance, state_string);=0A=
//MainMessage("PSB") ;
=0A=

    free(state_string);=0A=

=0A=

    while ((verdict =3D=3D FCS_STATE_SUSPEND_PROCESS) && =0A=

           (=0A=

                (limit > 0) ? =0A=

                    (current_limit < limit) :=0A=

                    1=0A=

           )=0A=

          )=0A=

    {=0A=

//        if (signal_step(current_limit, signal_step_context) !=3D 0)=0A=

        if (signal_step(current_limit) !=3D 0)=0A=

        {=0A=

            break;=0A=

        }=0A=

        current_limit +=3D 1000;=0A=

        freecell_solver_user_limit_iterations(instance, current_limit);=0A=

        verdict =3D freecell_solver_user_resume_solution(instance);=0A=

    }=0A=

=0A=

    num_iters =3D freecell_solver_user_get_num_times(instance);=0A=

=0A=

//    *ret_moves =3D NULL;=0A=

=0A=

    if (verdict =3D=3D FCS_STATE_WAS_SOLVED)=0A=

    {=0A=

        int num_moves;=0A=

        int a;=0A=

        fcs_extended_move_t move;=0A=

        char * str, * moves_string_proto;=0A=

        int len;=0A=

        moves_processed_t * moves_processed;=0A=

=0A=

        ret =3D num_iters;=0A=

        =0A=

        moves_processed =3D moves_processed_gen(orig, NoFcs, instance);=0A=

        num_moves =3D moves_processed_get_moves_left(moves_processed);=0A=

#ifdef SHLOMIF_DEBUG=0A=

        moves_string_proto =3D (char =
*)malloc(moves_processed->num_moves*8+1);=0A=

#else=0A=

        moves_string_proto =3D (char =
*)malloc(moves_processed->num_moves*4+1);=0A=

#endif=0A=

        =0A=

        /* a =3D num_moves-1; */=0A=

        str =3D moves_string_proto;=0A=

#ifdef SHLOMIF_DEBUG=0A=

        len =3D 0;=0A=

#endif=0A=

        while (! moves_processed_get_next_move(moves_processed, &move))=0A=

        {=0A=

=0A=

            str =3D render_move(move, str);=0A=

#ifdef SHLOMIF_DEBUG            =0A=

            *(str++) =3D ' ';=0A=

            if ((++len % 10) =3D=3D 0)=0A=

            {=0A=

                *(str++) =3D '\n';=0A=

            }=0A=

            *(str) =3D '\0';=0A=

#endif=0A=

        }=0A=

        moves_processed_free(moves_processed);=0A=

#ifndef SHLOMIF_DEBUG=0A=

        len =3D str-moves_string_proto;=0A=

        moves_string =3D malloc(len+1);=0A=

        for(a=3D0;a<len;a++)=0A=

        {=0A=

            moves_string[a] =3D moves_string_proto[len-1-a];=0A=

        }=0A=

        moves_string[a] =3D '\0';=0A=

        free(moves_string_proto);=0A=

#else=0A=

        moves_string =3D moves_string_proto;=0A=

#endif=0A=


#if 0=0A=

        moves_string[num_moves*2] =3D '\0';=0A=

#endif=0A=

=0A=

//        *ret_moves =3D moves_string;=0A=

    }=0A=

    else if (verdict =3D=3D FCS_STATE_IS_NOT_SOLVEABLE)=0A=

    {=0A=

		if (num_iters =3D=3D 0)=0A=

			num_iters++ ;=0A=

        ret =3D -num_iters;=0A=

    }=0A=

    else if ((verdict =3D=3D FCS_STATE_SUSPEND_PROCESS) || (verdict =
=3D=3D FCS_STATE_BEGIN_SUSPEND_PROCESS))=0A=

    {=0A=

        ret =3D 0;=0A=

    }=0A=

//MainMessage("FPI Exit1") ;       =20
    =0A=

    freecell_solver_user_free(instance);=0A=

=0A=
//MainMessage("FPI Exit2") ;       =20

    return ret;=0A=

}=0A=

=0A=

#if 0=0A=

=0A=

static int my_signal_step(int step_limit)=0A=

{=0A=

    printf("num_iters=3D%i\n", step_limit);=0A=

    return 0;=0A=

}=0A=
#if 0
int main(int argc, char * argv[])=0A=

{=0A=

    Position mypos;=0A=

    int ret;=0A=

=0A=

#include "fill_pos.cpp"=0A=

=0A=

    ret =3D Free2Solver(&mypos, 4, 150000, argc-1, argv+1, =
my_signal_step);=0A=

=0A=

    printf("%i\n", ret);=0A=

=0A=

    printf("%s\n", moves_string);=0A=

=0A=

    return 0;=0A=

}=0A=
#endif
#endif=0A=


------=_NextPart_000_0004_01C22407.55AF0660--

